
  <!DOCTYPE html>
  <html>
    <head>
      <title>FlowTree.tsx</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">client/src/components/Visualizer/FlowTree.tsx</td><td class="">100.00%</td><td class="">95%</td><td class="">413</td><td class="">413</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import React, { useState, useEffect, useCallback } from &#x27;react&#x27;;
import ReactFlow, { Controls, Background, applyEdgeChanges, applyNodeChanges, MiniMap, NodeChange, EdgeChange, Edge, Node, MarkerType, XYPosition } from &#x27;reactflow&#x27;;
import { parse, DocumentNode, FieldNode, SelectionNode, OperationDefinitionNode } from &#x27;graphql&#x27;;
import styles from &#x27;./Visualizer.modules.css&#x27;;


// type for NodeData
// data describes the content of the node
interface NodeData {
  id: string;
  data?: { label: string } ;
  position?: {
    x: number;
    y: number;
  };
  style?: React.CSSProperties;
  type?: string;
}

// type for FlowElement
interface FlowElement extends NodeData {
  id: string;
  position?: Position;
  target: string;
  source: string;
  animated?: boolean | undefined;
  label?: React.ReactNode;
  markerEnd?: {
    type: MarkerType;
    width?: number;
    height?: number;
    color?: string;
  } | string;
  style?: React.CSSProperties;
  labelStyle?: React.CSSProperties;
  labelBgBorderRadius?: number;
}

interface Position {
  x: number;
  y: number;
}


// declares prop x on Position
interface PositionWithX extends Position {
  x: number;
}


// turns ast field to node
const getNode = (
  node: FieldNode | SelectionNode | OperationDefinitionNode,
  depth: number,
  siblingIndex: number,
  numSiblings: number,
  numNodes: number,
  parentPosition?: Position,
): NodeData =&gt; {
  const label = node.kind === &#x27;Field&#x27; ? node.name.value : node.kind;
  const id = `${node.loc?.start}-${node.loc?.end}`;
  const parentX = parentPosition ? (parentPosition as PositionWithX).x : 0;
  const x = ((siblingIndex + 0.3) / 3) * 400 + 230 ;
  return {
    id: id!,
    data: {label},
    position: {
      y: 100 + depth * 100,
      x: parentX + x - (numSiblings / 2) * 290,
    },
    style:  {
      width: 125, 
      height: 30, 
      fontSize: 18, 
      border: `none`, 
      borderRadius: 12, 
      boxShadow: `0px 0px 3px #11262C`,
      padding: `2px 0px 0px 0px`
    }
  };
};



// gets edge connection between parent/child nodes
// edge is the thing that visually connects the parent/child node together

const getEdge = (parent: FieldNode, child: SelectionNode, elapsed: { [key: string]: number }): FlowElement =&gt; {
  const parentId = `${parent.loc?.start}-${parent.loc?.end}`;
  const childId = `${child.loc?.start}-${child.loc?.end}`;
  const edgeProps : FlowElement = {
    id: `${parentId}-${childId}`,
    source: parentId,
    target: childId,
    animated: false,
    markerEnd: {
      type: MarkerType.ArrowClosed,
      width: 10,
      height: 10,
      color: &#x27;#03C6FF&#x27;
    },
    style: {
      strokeWidth: 2,
      stroke: &#x27;#03C6FF&#x27;
    },
    labelStyle: {
      fontSize: 14,
    },
    labelBgBorderRadius: 10,
  };

  const childNode = child as FieldNode;
  // console.log(childNode.name.value);
  if(elapsed[childNode.name.value]){
    edgeProps.label = `${elapsed[childNode.name.value]}ms`;
  }
  return edgeProps;
};

// recursively constructs a tree structure from GraphQL AST
const buildTree = (
  node: FieldNode | SelectionNode,
  nodes: NodeData[],
  edges: FlowElement[],
  elapsed: {}, 
  depth = 0,
  siblingIndex = 0,
  numSiblings = 1,
  parentPosition?: Position
): void =&gt; {
  // gets the parent node and pushes it into the nodes array
  const parent = getNode(node, depth, siblingIndex, numSiblings, numSiblings, parentPosition);
  nodes.push(parent);

  // console.log(&quot;Parent node: &quot;, parent);
  // the selectionSet means that it has child nodes
  if (node.kind === &#x27;Field&#x27; &amp;&amp; node.selectionSet) {
    const numChildren = node.selectionSet.selections.length;
    // forEach childNode it will call getNode
    node.selectionSet.selections.forEach((childNode, i) =&gt; {
      const child = getNode(childNode, depth + 1, i, numChildren, numSiblings, parent.position);
      //pushes the child node and edge into the respective arrays
      edges.push(getEdge(node as FieldNode, childNode, elapsed));
      buildTree(childNode, nodes, edges, elapsed, depth + 1, i, numChildren, parent.position);
    });
  }
};



// takes the ast and returns nodes and edges as arrays for ReactFlow to render
const astToTree = (query: string, elapsed: {}): { nodes: NodeData[]; edges: FlowElement[] } =&gt; {
  const ast: DocumentNode = parse(query);
  const operation = ast.definitions.find(
    (def) =&gt; def.kind === &#x27;OperationDefinition&#x27; &amp;&amp; def.selectionSet
  );
  if (!operation) {
    throw new Error(&#x27;No operation definition found in query&#x27;);
  }
  const selections = (operation as OperationDefinitionNode).selectionSet.selections;
  const nodes: NodeData[] = [];
  const edges: FlowElement[] = [];
  let currentX = 0; // Adjust the initial x position for the first tree
  let currentY = 0; // Adjust the initial y position for the first tree

  selections.forEach((selection, index) =&gt; {
    const numSiblings = selections.length;
    const siblingIndex = index;
    const x = ((siblingIndex + 0.5) / numSiblings) * 900 + currentX;
    const y = 100 + currentY;

    buildTree(selection, nodes, edges, elapsed, 0, siblingIndex, numSiblings, { x, y });

  });

  return { nodes, edges };
};





// render a tree graph from GraphQL AST
const FlowTree: React.FC&lt;{query: string, elapsed: {} }&gt; = ({query, elapsed}) =&gt; {
  const [currentQuery, setCurrentQuery] = useState(query);
  const [elapsedTime, setElapsedTime] = useState(elapsed);

// update the state of nodes and edges when query changes
  useEffect(() =&gt; {
    const { nodes: newNodes, edges: newEdges } = astToTree(query, elapsedTime);
    const nodes = newNodes.map(node =&gt; {
      if (!node.position) {
        throw new Error(`Node with id ${node.id} does not have a position`);
      }
      return {
        id: node.id,
        data: node.data,
        position: node.position!,
        style: node.style
      }
    });
    setNodes(nodes);
    setEdges(newEdges);
    setCurrentQuery(query);
    setElapsedTime(elapsed);

} , [query, currentQuery, elapsed, elapsedTime]);


  const { nodes, edges } = astToTree(query, elapsedTime);

  // storing the initial values of the nodes and edges
  const [newNodes, setNodes] = useState&lt;NodeData[]&gt;(nodes);
  const [newEdges, setEdges] = useState&lt;FlowElement[]&gt;(edges);

  // setNodes/setEdges updates the state of the component causing it to re-render
  const onNodesChange = useCallback( (changes: NodeChange[]) =&gt; setNodes((nds) =&gt; applyNodeChanges(changes, nds)),[] );
  const onEdgesChange = useCallback( (changes: EdgeChange[]) =&gt; setEdges((eds) =&gt; applyEdgeChanges(changes, eds)),[] );
  
  // this is to remove the reactflow watermark
  const proOptions = { hideAttribution: true };
  
  return (
    &lt;ReactFlow 
    nodes={newNodes as Node&lt;any, string | undefined&gt;[]} 
    edges={newEdges as Edge&lt;any&gt;[]} 
    onNodesChange={onNodesChange}
    onEdgesChange={onEdgesChange}
    fitView
    proOptions={proOptions}
    &gt;
          &lt;Background /&gt;
          &lt;Controls /&gt;  
          &lt;MiniMap style={{height: 75, width: 75}}/&gt;
    &lt;/ReactFlow&gt;
  );
};


export default FlowTree;
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 22 Jun 2023 16:20:41 GMT</p>
    </body>
  </html>
  