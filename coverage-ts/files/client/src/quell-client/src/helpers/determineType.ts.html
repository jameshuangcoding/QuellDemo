
  <!DOCTYPE html>
  <html>
    <head>
      <title>determineType.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">client/src/quell-client/src/helpers/determineType.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">243</td><td class="">243</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  ASTNode,
  FieldNode,
  FragmentDefinitionNode,
  FragmentSpreadNode,
  OperationDefinitionNode,
  SelectionSetNode
} from &#x27;graphql&#x27;;
import { visit, BREAK } from &#x27;graphql/language/visitor&#x27;;

import {
  ProtoObjType,
  FragsType,
  ArgsObjType,
  FieldArgsType,
  GQLNodeWithDirectivesType,
  ValidArgumentNodeType,
  FieldsValuesType,
  FieldsObjectType
} from &#x27;../types&#x27;;

/**
 * Traverses the abstract syntax tree depth-first to determine which operations types are
 * &#x27;unQuellable&#x27; along the AST.
 * @param {Object} AST - Abstract syntax tree generated by GraphQL library.
 * @returns {Object} Object containing operation type is &#x27;unQuellable&#x27; and prototype object.
 */
export default function determineType(AST: ASTNode): {
  operationType: string;
  proto: ProtoObjType;
} {
  // Initialize prototype as empty object
  // Information from the AST is distilled into the prototype for easy
  // access during caching, rebuilding query strings, etc.
  const proto: ProtoObjType = {};

  // The frags object will contain the fragments defined in the query in a format
  // similar to the proto.
  const frags: FragsType = {};

  // Create an args object that will be populated with the node&#x27;s arguments.
  const argsObj: ArgsObjType = {};

  // Create variable target object that will be updated to point to prototype when iterating
  // through Field nodes and to point to frags when iterating through Fragment Definition nodes.
  let targetObj: ProtoObjType | FragsType;

  // Create operation type variable. This will be &#x27;query&#x27;, &#x27;mutation&#x27;, &#x27;subscription&#x27;, &#x27;noID&#x27;, or &#x27;unQuellable&#x27;.
  let operationType = &#x27;&#x27;;

  // Initialize a stack to keep track of depth first parsing path.
  const stack: string[] = [];

  // Tracks depth of selection Set
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  let selectionSetDepth = 0;

  // Create field arguments object, which will track the id, type, alias, and args for the fields.
  // The field arguments object will eventually be merged with the prototype object.
  const fieldArgs: FieldArgsType = {};

  /**
   * visit is a utility provided in the graphql-JS library. It performs a
   * depth-first traversal of the abstract syntax tree, invoking a callback
   * when each SelectionSet node is entered. That function builds the prototype.
   * Invokes a callback when entering and leaving Field node to keep track of nodes with stack
   *
   * Find documentation at:
   * https://graphql.org/graphql-js/language/#visit
   */
  visit(AST, {
    // The enter function will be triggered upon entering each node in the traversal.
    enter(node: ASTNode) {
      // Quell cannot cache directives, so we need to return as unQuellable if the node has directives.
      if ((node as GQLNodeWithDirectivesType)?.directives) {
        if ((node as GQLNodeWithDirectivesType)?.directives?.length ?? 0 &gt; 0) {
          operationType = &#x27;unQuellable&#x27;;
          // Return BREAK to break out of the current traversal branch.
          return BREAK;
        }
      }
    },

    // If the current node is of type OperationDefinition, this function will be triggered upon entering it.
    // It checks the type of operation being performed.
    OperationDefinition(node: OperationDefinitionNode) {
      targetObj = proto;
      // Quell cannot cache subscriptions, so we need to return as unQuellable if the type is subscription.
      operationType = node.operation;
      if (operationType === &#x27;subscription&#x27;) {
        operationType = &#x27;unQuellable&#x27;;
        // Return BREAK to break out of the current traversal branch.
        return BREAK;
      }
    },

    // If the current node is of type FragmentDefinition, this function will be triggered upon entering it.
    FragmentDefinition: {
      enter(node: FragmentDefinitionNode) {
        // Get the name of the fragment.
        const fragName: string = node.name.value;

        // Add the fragment name to the stack.
        stack.push(fragName);

        // Add the fragment name as a key in the target object (which will be frags while inside the
        // loop below), initialized to an empty object.
        targetObj = frags;
        targetObj[fragName] = {};

        // Loop through the selections in the selection set for the current FragmentDefinition node
        // in order to extract the fields in the fragment.
        for (let i = 0; i &lt; node.selectionSet.selections.length; i++) {
          // Below, we get the &#x27;name&#x27; property from the SelectionNode.
          // However, InlineFragmentNode (one of the possible types for SelectionNode) does
          // not have a &#x27;name&#x27; property, so we will want to skip nodes with that type.
          if (node.selectionSet.selections[i].kind !== &#x27;InlineFragment&#x27;) {
            // Add base-level field names in the fragment to the frags (aka target) object.
            (targetObj as FragsType)[fragName][
              (
                node.selectionSet.selections[i] as
                  | FieldNode
                  | FragmentSpreadNode
              ).name.value
            ] = true;
          }
        }
      },

      // If the current node is of type FragmentDefinition, this function will be triggered after visiting it and all of its children.
      leave() {
        // Pop stacks to keep track of depth-first parsing path.
        stack.pop();
      }
    },

    Field: {
      // If the current node is of type Field, this function will be triggered upon entering it.
      enter(node: FieldNode) {
        // Return introspection queries as unQuellable so that we do not cache them.
        // &quot;__keyname&quot; syntax is later used for Quell&#x27;s field-specific options, though this does not create collision with introspection.
        if (node.name.value.includes(&#x27;__&#x27;)) {
          operationType = &#x27;unQuellable&#x27;;
          // Return BREAK to break out of the current traversal branch.
          return BREAK;
        }

        // Loop through the field&#x27;s arguments.
        if (node.arguments) {
          node.arguments.forEach((arg) =&gt; {
            const key: string = arg.name.value;

            // Quell cannot cache queries with variables, so we need to return unQuellable if the query has variables.
            if (arg.value.kind === &#x27;Variable&#x27; &amp;&amp; operationType === &#x27;query&#x27;) {
              operationType = &#x27;unQuellable&#x27;;
              // Return BREAK to break out of the current traversal branch.
              return BREAK;
            }

            /*
             * In the next step, we get the value from the argument node&#x27;s value node.
             * This assumes that the value node has a &#x27;value&#x27; property.
             * If the &#x27;kind&#x27; of the value node is ObjectValue, ListValue, NullValue, or ListValue
             * then the value node will not have a &#x27;value&#x27; property, so we must first check that
             * the &#x27;kind&#x27; does not match any of those types.
             */
            if (
              arg.value.kind === &#x27;NullValue&#x27; ||
              arg.value.kind === &#x27;ObjectValue&#x27; ||
              arg.value.kind === &#x27;ListValue&#x27;
            ) {
              operationType = &#x27;unQuellable&#x27;;
              // Return BREAK to break out of the current traversal branch.
              return BREAK;
            }

            // Assign argument values to argsObj (key will be argument name, value will be argument value),
            // skipping field-specific options (&#x27;__&#x27;) provided as arguments.
            if (!key.includes(&#x27;__&#x27;)) {
              argsObj[key] = (arg.value as ValidArgumentNodeType).value;
            }
          });
        }

        // Set the fieldType equal to either the field&#x27;s alias or the field&#x27;s name.
        const fieldType: string = node.alias
          ? node.alias.value
          : node.name.value;

        // Add the field type to stacks to keep track of depth-first parsing path.
        stack.push(fieldType);
      },

      // If the current node is of type Field, this function will be triggered after visiting it and all of its children.
      leave() {
        // Pop stacks to keep track of depth-first parsing path.
        stack.pop();
      }
    },
    SelectionSet: {
      // If the current node is of type SelectionSet, this function will be triggered upon entering it.
      // The selection sets contain all of the sub-fields.
      // Iterate through the sub-fields to construct fieldsObject
      enter(
        node: SelectionSetNode,
        key: string | number | undefined,
        parent: ASTNode | readonly ASTNode[] | undefined,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        path: readonly (string | number)[],
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        ancestors: readonly (ASTNode | readonly ASTNode[])[]
      ) {
        selectionSetDepth++;

        /*
         * Exclude SelectionSet nodes whose parents are not of the kind
         * &#x27;Field&#x27; to exclude nodes that do not contain information about
         *  queried fields.
         */
        if (
          parent &amp;&amp; // parent is not undefined
          !Array.isArray(parent) &amp;&amp; // parent is not readonly ASTNode[]
          (parent as ASTNode).kind === &#x27;Field&#x27; // can now safely assume that parent will have &#x27;kind&#x27; property
        ) {
          // Create fieldsValues object that will be used to collect fields as
          // we loop through the selections.
          const fieldsValues: FieldsValuesType = {};

          for (const field of node.selections) {
            /*
             * If the current selection in the selections array is not a nested object
             * (i.e. does not have a SelectionSet), set its value in fieldsValues to true.
             * Below, we get the &#x27;name&#x27; property from the SelectionNode.
             * However, InlineFragmentNode (one of the possible types for SelectionNode) does
             * not have a &#x27;name&#x27; property, so we will want to skip nodes with that type.
             * Furthermore, FragmentSpreadNodes never have a selection set property.
             */
            if (
              field.kind !== &#x27;InlineFragment&#x27; &amp;&amp;
              (field.kind === &#x27;FragmentSpread&#x27; || !field.selectionSet)
            )
              fieldsValues[field.name.value] = true;
          }

          // If ID was not included on the request and the current node is not a fragment, then the query
          // will not be included in the cache, but the request will be processed.
          if (
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;id&#x27;) &amp;&amp;
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;_id&#x27;) &amp;&amp;
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;ID&#x27;) &amp;&amp;
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;Id&#x27;)
          ) {
            operationType = &#x27;unQuellable&#x27;;
            // Return BREAK to break out of the current traversal branch.
            return BREAK;
          }
          // Place current fieldArgs object onto fieldsObject so it gets passed along to prototype.
          // The fieldArgs contains arguments, aliases, etc.
          const fieldsObject: FieldsObjectType = {
            ...fieldsValues,
            ...fieldArgs[stack[stack.length - 1]]
          };

          // Loop through stack to get correct path in proto for temp object;
          // mutates original prototype object WITH values from tempObject
          // &quot;prev&quot; is accumulator ie the prototype
          stack.reduce(
            (prev: ProtoObjType, curr: string, index: number): ProtoObjType =&gt; {
              // if last item in path, set value
              if (index + 1 === stack.length) prev[curr] = { ...fieldsObject };
              return prev[curr] as ProtoObjType;
            },
            targetObj
          );
        }
      },
      leave() {
        // Tracking depth of selection set
        selectionSetDepth--;
      }
    }
  });
  return { operationType, proto };
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 22 Jun 2023 16:20:41 GMT</p>
    </body>
  </html>
  