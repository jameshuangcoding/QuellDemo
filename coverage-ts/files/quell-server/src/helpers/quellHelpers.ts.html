
  <!DOCTYPE html>
  <html>
    <head>
      <title>quellHelpers.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">quell-server/src/helpers/quellHelpers.ts</td><td class="">92.60%</td><td class="">95%</td><td class="">865</td><td class="">801</td><td class="">64</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { visit, BREAK } from &#x27;graphql/language/visitor&#x27;;
import type {
  GraphQLSchema,
  ASTNode,
  DocumentNode,
  OperationDefinitionNode,
  FragmentDefinitionNode,
  FieldNode,
  SelectionSetNode,
  ArgumentNode,
  FragmentSpreadNode
} from &#x27;graphql&#x27;;
import type {
  ProtoObjType,
  FragsType,
  MutationMapType,
  QueryMapType,
  FieldsMapType,
  ParseASTOptions,
  ArgsObjType,
  FieldArgsType,
  AuxObjType,
  ValidArgumentNodeType,
  FieldsObjectType,
  FieldsValuesType,
  GQLNodeWithDirectivesType,
  QueryObject,
  QueryFields,
  MergedResponse,
  DataResponse,
  Data
} from &#x27;../types&#x27;;

/**
 * Traverses over a supplied query Object and uses the fields on there to create a query string reflecting the data.
 * This query string is a modified version of the query string received by Quell that has references to data found within the cache removed
 * so that the final query is faster and reduced in scope.
 * @param {Object} queryObject - A modified version of the prototype with only values we want to pass onto the queryString.
 * @param {string} operationType - A string indicating the GraphQL operation type- &#x27;query&#x27;, &#x27;mutation&#x27;, etc.
 */
export function createQueryStr(
  queryObject: QueryObject | ProtoObjType,
  operationType: string
): string {
  if (Object.keys(queryObject).length === 0) return &#x27;&#x27;;
  const openCurly = &#x27;{&#x27;;
  const closeCurly = &#x27;}&#x27;;
  const openParen = &#x27;(&#x27;;
  const closeParen = &#x27;)&#x27;;

  let mainStr = &#x27;&#x27;;

  // iterate over every key in queryObject
  // place key into query object
  for (const key in queryObject) {
    mainStr += ` ${key}${getAliasType(
      queryObject[key] as QueryFields
    )}${getArgs(queryObject[key] as QueryFields)} ${openCurly} ${stringify(
      queryObject[key] as QueryFields
    )}${closeCurly}`;
  }

  /**
   * Helper function that is used to recursively build a GraphQL query string from a nested object,
   * ignoring any __values (ie __alias and __args).
   * @param {QueryFields} fields - An object whose properties need to be converted to a string to be used for a GraphQL query.
   * @returns {string} innerStr - A graphQL query string.
   */
  function stringify(fields: QueryFields): string {
    // initialize inner string
    let innerStr = &#x27;&#x27;;
    // iterate over KEYS in OBJECT
    for (const key in fields) {
      // is fields[key] string? concat with inner string &amp; empty space
      if (typeof fields[key] === &#x27;boolean&#x27;) {
        innerStr += key + &#x27; &#x27;;
      }
      // is key object? &amp;&amp; !key.includes(&#x27;__&#x27;), recurse stringify
      if (typeof fields[key] === &#x27;object&#x27; &amp;&amp; !key.includes(&#x27;__&#x27;)) {
        const fieldsObj: QueryFields = fields[key] as QueryFields;
        // TODO try to fix this error
        const type: string = getAliasType(fieldsObj);
        const args: string = getArgs(fieldsObj);
        innerStr += `${key}${type}${args} ${openCurly} ${stringify(
          fieldsObj
        )}${closeCurly} `;
      }
    }

    return innerStr;
  }

  /**
   * Helper function that iterates through arguments object for current field and creates
   * an argument string to attach to the query string.
   * @param {QueryFields} fields - Object whose arguments will be attached to the query string.
   * @returns {string} Argument string to be attached to the query string.
   */
  function getArgs(fields: QueryFields): string {
    let argString = &#x27;&#x27;;
    if (!fields.__args) return &#x27;&#x27;;

    Object.keys(fields.__args).forEach((key) =&gt; {
      argString
        ? (argString += `, ${key}: &quot;${(fields.__args as QueryFields)[key]}&quot;`)
        : (argString += `${key}: &quot;${(fields.__args as QueryFields)[key]}&quot;`);
    });

    // return arg string in parentheses, or if no arguments, return an empty string
    return argString ? `${openParen}${argString}${closeParen}` : &#x27;&#x27;;
  }

  /**
   * Helper function that formats the field&#x27;s alias, if it exists, for the query string.
   * @param {QueryFields} fields - Object whose alias will be attached to the query string.
   * @returns {string} Alias string to be attached to the query string.
   */
  function getAliasType(fields: QueryFields): string {
    return fields.__alias ? `: ${fields.__type}` : &#x27;&#x27;;
  }

  // Create the final query string.
  const queryStr: string = openCurly + mainStr + &#x27; &#x27; + closeCurly;
  return operationType ? operationType + &#x27; &#x27; + queryStr : queryStr;
}

/**
 * Takes in a map of fields and true/false values (the prototype) and creates a query object containing any values missing from the cache.
 * The resulting queryObj is then used as a template to create GraphQL query strings.
 * @param {ProtoObjType} map - Map of fields and true/false values from initial request, should be the prototype.
 * @returns {Object} queryObject that includes only the values to be requested from GraphQL endpoint.
 */
export function createQueryObj(map: ProtoObjType): ProtoObjType {
  const output: ProtoObjType = {};
  // iterate over every key in map
  // true values are filtered out, false values are placed on output
  for (const key in map) {
    const reduced: ProtoObjType = reducer(map[key] as ProtoObjType);
    if (Object.keys(reduced).length &gt; 0) {
      output[key] = reduced;
    }
  }

  /**
   * Takes in a fields object and returns only the values needed from the server.
   * @param {Object} fields - Object containing true or false values that determines what should be
   * retrieved from the server.
   * @returns {Object} Filtered object of only queries without a value or an empty object.
   */
  function reducer(fields: ProtoObjType): ProtoObjType {
    // Create a filter object to store values needed from server.
    const filter: ProtoObjType = {};
    // Create a propsFilter object for properties such as args, aliases, etc.
    const propsFilter: ProtoObjType = {};

    for (const key in fields) {
      // If value is false, place directly on filter
      if (fields[key] === false) {
        filter[key] = false;
      }
      // Force the id onto the query object
      if (key === &#x27;id&#x27; || key === &#x27;_id&#x27; || key === &#x27;ID&#x27; || key === &#x27;Id&#x27;) {
        filter[key] = false;
      }

      // If value is an object, recurse to determine nested values
      if (typeof fields[key] === &#x27;object&#x27; &amp;&amp; !key.includes(&#x27;__&#x27;)) {
        const reduced: ProtoObjType = reducer(fields[key] as ProtoObjType);
        // if reduced object has any values to pass, place on filter
        if (Object.keys(reduced).length &gt; 1) {
          filter[key] = reduced;
        }
      }

      // If reserved property such as args or alias, place on propsFilter
      if (key.includes(&#x27;__&#x27;)) {
        propsFilter[key] = fields[key];
      }
    }

    const numFields: number = Object.keys(fields).length;

    // If the filter has any values to pass, return filter &amp; propsFilter; otherwise return empty object
    return Object.keys(filter).length &gt; 1 &amp;&amp; numFields &gt; 5
      ? { ...filter, ...propsFilter }
      : {};
  }
  return output;
}

/**
 * Combines two objects containing results from separate sources and outputs a single object with information from both sources combined,
 * formatted to be delivered to the client, using the queryProto as a template for how to structure the final response object.
 * @param {Object} cacheResponse - Response data from the cache.
 * @param {Object} serverResponse - Response data from the server or external API.
 * @param {Object} queryProto - Current slice of the prototype being used as a template for final response object structure.
 * @param {boolean} fromArray - Whether or not the current recursive loop came from within an array (should NOT be supplied to function call).
 */
export function joinResponses(
  cacheResponse: DataResponse,
  serverResponse: DataResponse,
  queryProto: QueryObject | ProtoObjType,
  fromArray = false
): MergedResponse {
  let mergedResponse: MergedResponse = {};

  // loop through fields object keys, the &quot;source of truth&quot; for structure
  // store combined responses in mergedResponse
  for (const key in queryProto) {
    // for each key, check whether data stored at that key is an array or an object
    const checkResponse: DataResponse = Object.prototype.hasOwnProperty.call(
      serverResponse,
      key
    )
      ? serverResponse
      : cacheResponse;
    if (Array.isArray(checkResponse[key])) {
      // merging logic depends on whether the data is on the cacheResponse, serverResponse, or both
      // if both of the caches contain the same keys...
      if (cacheResponse[key] &amp;&amp; serverResponse[key]) {
        // we first check to see if the responses have identical keys to both avoid
        // only returning 1/2 of the data (ex: there are 2 objects in the cache and
        // you query for 4 objects (which includes the 2 cached objects) only returning
        // the 2 new objects from the server)
        // if the keys are identical, we can return a &quot;simple&quot; merge of both
        const cacheKeys: string[] = Object.keys(
          (cacheResponse[key] as Data)[0]
        );
        const serverKeys: string[] = Object.keys(
          (serverResponse[key] as Data)[0]
        );
        let keysSame = true;
        for (let n = 0; n &lt; cacheKeys.length; n++) {
          if (cacheKeys[n] !== serverKeys[n]) keysSame = false;
        }
        if (keysSame) {
          mergedResponse[key] = [
            ...(cacheResponse[key] as Data[]),
            ...(serverResponse[key] as Data[])
          ];
        }
        // otherwise, we need to combine the responses at the object level
        else {
          const mergedArray = [];
          for (let i = 0; i &lt; (cacheResponse[key] as Data[]).length; i++) {
            // for each index of array, combine cache and server response objects
            const joinedResponse: MergedResponse = joinResponses(
              { [key]: (cacheResponse[key] as Data[])[i] },
              { [key]: (serverResponse[key] as Data[])[i] },
              { [key]: queryProto[key] },
              true
            );
            mergedArray.push(joinedResponse);
          }
          mergedResponse[key] = mergedArray;
        }
      } else if (cacheResponse[key]) {
        mergedResponse[key] = cacheResponse[key];
      } else {
        mergedResponse[key] = serverResponse[key];
      }
    } else {
      if (!fromArray) {
        // if object doesn&#x27;t come from an array, we must assign on the object at the given key
        mergedResponse[key] = {
          ...cacheResponse[key],
          ...serverResponse[key]
        };
      } else {
        // if the object comes from an array, we do not want to assign to a key as per GQL spec
        (mergedResponse as object) = {
          ...cacheResponse[key],
          ...serverResponse[key]
        };
      }

      for (const fieldName in queryProto[key] as ProtoObjType) {
        // check for nested objects
        if (
          typeof (queryProto[key] as ProtoObjType)[fieldName] === &#x27;object&#x27; &amp;&amp;
          !fieldName.includes(&#x27;__&#x27;)
        ) {
          // recurse joinResponses on that object to create deeply nested copy on mergedResponse
          let mergedRecursion: MergedResponse = {};
          if (cacheResponse[key] &amp;&amp; serverResponse[key]) {
            if (
              (cacheResponse[key] as Data)[fieldName] &amp;&amp;
              (serverResponse[key] as Data)[fieldName]
            ) {
              mergedRecursion = joinResponses(
                {
                  [fieldName]: (cacheResponse[key] as DataResponse)[fieldName]
                },
                {
                  [fieldName]: (serverResponse[key] as DataResponse)[fieldName]
                },
                { [fieldName]: (queryProto[key] as QueryObject)[fieldName] }
              );
            } else if ((cacheResponse[key] as Data)[fieldName]) {
              mergedRecursion[fieldName] = (
                cacheResponse[key] as MergedResponse
              )[fieldName];
            } else {
              mergedRecursion[fieldName] = (
                serverResponse[key] as MergedResponse
              )[fieldName];
            }
          }
          // place on merged response, spreading the mergedResponse[key] if it
          // is an object or an array, or just adding it as a value at key otherwise
          if (
            typeof mergedResponse[key] === &#x27;object&#x27; ||
            Array.isArray(mergedResponse[key])
          ) {
            mergedResponse[key] = {
              ...(mergedResponse[key] as MergedResponse | MergedResponse[]),
              ...mergedRecursion
            };
          } else {
            // case for when mergedResponse[key] is not an object or array and possibly
            // boolean or a string
            mergedResponse[key] = {
              key: mergedResponse[key] as Data | boolean,
              ...mergedRecursion
            };
          }
        }
      }
    }
  }
  return mergedResponse;
}

/**
 * Traverses the abstract syntax tree depth-first to create a template for future operations, such as
 * request data from the cache, creating a modified query string for additional information needed, and joining cache and database responses.
 * @param {Object} AST - An abstract syntax tree generated by GraphQL library that we will traverse to build our prototype.
 * @param {Object} options - (not fully integrated) A field for user-supplied options.
 * @returns {Object} prototype object
 * @returns {string} operationType
 * @returns {Object} frags object
 */
export function parseAST(
  AST: DocumentNode,
  options: ParseASTOptions = { userDefinedID: null }
): { proto: ProtoObjType; operationType: string; frags: FragsType } {
  // Initialize prototype and frags as empty objects.
  // Information from the AST is distilled into the prototype for easy
  // access during caching, rebuilding query strings, etc.
  const proto: ProtoObjType = {};

  // The frags object will contain the fragments defined in the query in a format
  // similar to the proto.
  const frags: FragsType = {};

  // Create operation type variable. This will be &#x27;query&#x27;, &#x27;mutation&#x27;, &#x27;subscription&#x27;, &#x27;noID&#x27;, or &#x27;unQuellable&#x27;.
  let operationType = &#x27;&#x27;;

  // Initialize a stack to keep track of depth first parsing path.
  const stack: string[] = [];

  // Create field arguments object, which will track the id, type, alias, and args for the fields.
  // The field arguments object will eventually be merged with the prototype object.
  const fieldArgs: FieldArgsType = {};

  // Extract the userDefinedID from the options object, if provided.
  const userDefinedID: string | null | undefined = options.userDefinedID;

  /**
   * visit is a utility provided in the graphql-JS library. It performs a
   * depth-first traversal of the abstract syntax tree, invoking a callback
   * when each SelectionSet node is entered. That function builds the prototype.
   * Invokes a callback when entering and leaving Field node to keep track of nodes with stack
   *
   * Find documentation at:
   * https://graphql.org/graphql-js/language/#visit
   */
  visit(AST, {
    // The enter function will be triggered upon entering each node in the traversal.
    enter(node: ASTNode) {
      // Quell cannot cache directives, so we need to return as unQuellable if the node has directives.
      if ((node as GQLNodeWithDirectivesType)?.directives) {
        if ((node as GQLNodeWithDirectivesType)?.directives?.length ?? 0 &gt; 0) {
          operationType = &#x27;unQuellable&#x27;;
          // Return BREAK to break out of the current traversal branch.
          return BREAK;
        }
      }
    },

    // If the current node is of type OperationDefinition, this function will be triggered upon entering it.
    // It checks the type of operation being performed.
    OperationDefinition(node: OperationDefinitionNode) {
      // Quell cannot cache subscriptions, so we need to return as unQuellable if the type is subscription.
      operationType = node.operation;
      if (operationType === &#x27;subscription&#x27;) {
        operationType = &#x27;unQuellable&#x27;;
        // Return BREAK to break out of the current traversal branch.
        return BREAK;
      }
    },

    // If the current node is of type FragmentDefinition, this function will be triggered upon entering it.
    FragmentDefinition(node: FragmentDefinitionNode) {
      // Get the name of the fragment.
      const fragName = node.name.value;

      // Add the fragment name to the stack.
      stack.push(fragName);

      // Add the fragment name as a key in the frags object, initialized to an empty object.
      frags[fragName] = {};

      // Loop through the selections in the selection set for the current FragmentDefinition node
      // in order to extract the fields in the fragment.
      for (let i = 0; i &lt; node.selectionSet.selections.length; i++) {
        // Below, we get the &#x27;name&#x27; property from the SelectionNode.
        // However, InlineFragmentNode (one of the possible types for SelectionNode) does
        // not have a &#x27;name&#x27; property, so we will want to skip nodes with that type.
        if (node.selectionSet.selections[i].kind !== &#x27;InlineFragment&#x27;) {
          // Add base-level field names in the fragment to the frags object.
          frags[fragName][
            (
              node.selectionSet.selections[i] as FieldNode | FragmentSpreadNode
            ).name.value
          ] = true;
        }
      }
    },

    Field: {
      // If the current node is of type Field, this function will be triggered upon entering it.
      enter(node: FieldNode) {
        // Return introspection queries as unQuellable so that we do not cache them.
        // &quot;__keyname&quot; syntax is later used for Quell&#x27;s field-specific options, though this does not create collision with introspection.
        if (node.name.value.includes(&#x27;__&#x27;)) {
          operationType = &#x27;unQuellable&#x27;;
          // Return BREAK to break out of the current traversal branch.
          return BREAK;
        }

        // Create an args object that will be populated with the current node&#x27;s arguments.
        const argsObj: ArgsObjType = {};

        // Auxiliary object for storing arguments, aliases, field-specific options, and more.
        // Query-wide options should be handled on Quell&#x27;s options object.
        const auxObj: AuxObjType = {
          __id: null
        };

        // Loop through the field&#x27;s arguments.
        if (node.arguments) {
          node.arguments.forEach((arg: ArgumentNode) =&gt; {
            const key: string = arg.name.value;

            // Quell cannot cache queries with variables, so we need to return unQuellable if the query has variables.
            if (arg.value.kind === &#x27;Variable&#x27; &amp;&amp; operationType === &#x27;query&#x27;) {
              operationType = &#x27;unQuellable&#x27;;
              // Return BREAK to break out of the current traversal branch.
              return BREAK;
            }

            /*
             * In the next step, we get the value from the argument node&#x27;s value node.
             * This assumes that the value node has a &#x27;value&#x27; property.
             * If the &#x27;kind&#x27; of the value node is ObjectValue, ListValue, NullValue, or ListValue
             * then the value node will not have a &#x27;value&#x27; property, so we must first check that
             * the &#x27;kind&#x27; does not match any of those types.
             */
            if (
              arg.value.kind === &#x27;NullValue&#x27; ||
              arg.value.kind === &#x27;ObjectValue&#x27; ||
              arg.value.kind === &#x27;ListValue&#x27;
            ) {
              operationType = &#x27;unQuellable&#x27;;
              // Return BREAK to break out of the current traversal branch.
              return BREAK;
            }

            // Assign argument values to argsObj (key will be argument name, value will be argument value),
            // skipping field-specific options (&#x27;__&#x27;) provided as arguments.
            if (!key.includes(&#x27;__&#x27;)) {
              // Get the value from the argument node&#x27;s value node.
              argsObj[key] = (arg.value as ValidArgumentNodeType).value;
            }

            // If a userDefinedID was included in the options object and the current argument name matches
            // that ID, update the auxiliary object&#x27;s id.
            if (userDefinedID ? key === userDefinedID : false) {
              auxObj.__id = (arg.value as ValidArgumentNodeType).value;
            } else if (
              // If a userDefinedID was not provided, determine the uniqueID from the args.
              // Note: do not use key.includes(&#x27;id&#x27;) to avoid assigning fields such as &quot;idea&quot; or &quot;idiom&quot; as uniqueID.
              key === &#x27;id&#x27; ||
              key === &#x27;_id&#x27; ||
              key === &#x27;ID&#x27; ||
              key === &#x27;Id&#x27;
            ) {
              // If the name of the argument is &#x27;id&#x27;, &#x27;_id&#x27;, &#x27;ID&#x27;, or &#x27;Id&#x27;,
              // set the &#x27;__id&#x27; field on the auxObj equal to value of that argument.
              auxObj.__id = (arg.value as ValidArgumentNodeType).value;
            }
          });
        }

        // Gather other auxiliary data such as aliases, arguments, query type, and more to append to the prototype for future reference.

        // Set the fieldType (which will be the key in the fieldArgs object) equal to either the field&#x27;s alias or the field&#x27;s name.
        const fieldType: string = node.alias
          ? node.alias.value
          : node.name.value;

        // Set the &#x27;__type&#x27; property of the auxiliary object equal to the field&#x27;s name, converted to lower case.
        auxObj.__type = node.name.value.toLowerCase();

        // Set the &#x27;__alias&#x27; property of the auxiliary object equal to the field&#x27;s alias if it has one.
        auxObj.__alias = node.alias ? node.alias.value : null;

        // Set the &#x27;__args&#x27; property of the auxiliary object equal to the args
        auxObj.__args = Object.keys(argsObj).length &gt; 0 ? argsObj : null;

        // Add auxObj fields to prototype, allowing future access to type, alias, args, etc.
        fieldArgs[fieldType] = {
          ...auxObj
        };
        // Add the field type to stacks to keep track of depth-first parsing path.
        stack.push(fieldType);
      },

      // If the current node is of type Field, this function will be triggered after visiting it and all of its children.
      leave() {
        // Pop stacks to keep track of depth-first parsing path.
        stack.pop();
      }
    },

    SelectionSet: {
      // If the current node is of type SelectionSet, this function will be triggered upon entering it.
      // The selection sets contain all of the sub-fields.
      // Iterate through the sub-fields to construct fieldsObject
      enter(
        node: SelectionSetNode,
        key: string | number | undefined,
        parent: ASTNode | readonly ASTNode[] | undefined,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        path: readonly (string | number)[],
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        ancestors: readonly (ASTNode | readonly ASTNode[])[]
      ) {
        /*
         * Exclude SelectionSet nodes whose parents are not of the kind
         * &#x27;Field&#x27; to exclude nodes that do not contain information about
         *  queried fields.
         */
        // FIXME: It is possible for the parent to be an array. This happens when the selection set
        // is a fragment spread. In that case, the parent will not have a &#x27;kind&#x27; property. For now,
        // add a check that parent is not an array.
        if (
          parent &amp;&amp; // parent is not undefined
          !Array.isArray(parent) &amp;&amp; // parent is not readonly ASTNode[]
          (parent as ASTNode).kind === &#x27;Field&#x27; // can now safely cast parent to ASTNode
        ) {
          // Create fieldsValues object that will be used to collect fields as
          // we loop through the selections.
          const fieldsValues: FieldsValuesType = {};

          /*
           * Create a variable called fragment, initialized to false, to indicate whether the selection set includes a fragment spread.
           * Loop through the current selection set&#x27;s selections array.
           * If the array contains a FragmentSpread node, set the fragment variable to true.
           * This is reset to false upon entering each new selection set.
           */
          let fragment = false;
          for (const field of node.selections) {
            if (field.kind === &#x27;FragmentSpread&#x27;) fragment = true;
            /*
             * If the current selection in the selections array is not a nested object
             * (i.e. does not have a SelectionSet), set its value in fieldsValues to true.
             * Below, we get the &#x27;name&#x27; property from the SelectionNode.
             * However, InlineFragmentNode (one of the possible types for SelectionNode) does
             * not have a &#x27;name&#x27; property, so we will want to skip nodes with that type.
             * Furthermore, FragmentSpreadNodes never have a selection set property.
             */
            if (
              field.kind !== &#x27;InlineFragment&#x27; &amp;&amp;
              (field.kind === &#x27;FragmentSpread&#x27; || !field.selectionSet)
            )
              fieldsValues[field.name.value] = true;
          }
          // If ID was not included on the request and the current node is not a fragment, then the query
          // will not be included in the cache, but the request will be processed.
          if (
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;id&#x27;) &amp;&amp;
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;_id&#x27;) &amp;&amp;
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;ID&#x27;) &amp;&amp;
            !Object.prototype.hasOwnProperty.call(fieldsValues, &#x27;Id&#x27;) &amp;&amp;
            !fragment
          ) {
            operationType = &#x27;noID&#x27;;
            // Return BREAK to break out of the current traversal branch.
            return BREAK;
          }

          // Place current fieldArgs object onto fieldsObject so it gets passed along to prototype.
          // The fieldArgs contains arguments, aliases, etc.
          const fieldsObject: FieldsObjectType = {
            ...fieldsValues,
            ...fieldArgs[stack[stack.length - 1]]
          };
          // Loop through stack to get correct path in proto for temp object
          stack.reduce(
            (prev: ProtoObjType, curr: string, index: number): ProtoObjType =&gt; {
              // if last item in path, set value
              if (index + 1 === stack.length) prev[curr] = { ...fieldsObject };
              return prev[curr] as ProtoObjType;
            },
            proto
          );
        }
      },

      // If the current node is of type SelectionSet, this function will be triggered upon entering it.
      leave() {
        // Pop stacks to keep track of depth-first parsing path
        stack.pop();
      }
    }
  });
  return { proto, operationType, frags };
}

/**
 * Takes collected fragments and integrates them onto the prototype where referenced.
 * @param {Object} protoObj - Prototype before it has been updated with fragments.
 * @param {Object} frags - Fragments object to update prototype with.
 * @returns {Object} Updated prototype object.
 */
export function updateProtoWithFragment(
  protoObj: ProtoObjType,
  frags: FragsType
): ProtoObjType {
  // If the proto or frags objects are null/undefined, return the protoObj.
  if (!protoObj || !frags) return protoObj;

  // Loop through the fields in the proto object.
  for (const key in protoObj) {
    // If the field is a nested object and not an introspection field (fields starting with &#x27;__&#x27;
    // that provide information about the underlying schema)
    if (typeof protoObj[key] === &#x27;object&#x27; &amp;&amp; !key.includes(&#x27;__&#x27;)) {
      // Update the field to the result of recursively calling updateProtoWithFragment,
      // passing the field and fragments.
      protoObj[key] = updateProtoWithFragment(
        protoObj[key] as ProtoObjType,
        frags
      );
    }

    // If the field is a reference to a fragment, replace the reference to the fragment with
    // the actual fragment.
    if (Object.prototype.hasOwnProperty.call(frags, key)) {
      protoObj = { ...protoObj, ...frags[key] };
      delete protoObj[key];
    }
  }

  // Return the updated proto
  return protoObj;
}

/**
 *  Generates a map of mutation to GraphQL object types. This mapping is used
 *  to identify references to cached data when mutation occurs.
 *  @param {Object} schema - GraphQL defined schema that is used to facilitate caching by providing valid queries,
 *  mutations, and fields.
 *  @returns {Object} mutationMap - Map of mutations to GraphQL types.
 */
export function getMutationMap(schema: GraphQLSchema): MutationMapType {
  const mutationMap: MutationMapType = {};
  // get object containing all root mutations defined in the schema
  const mutationTypeFields: GraphQLSchema[&#x27;_mutationType&#x27;] = schema
    ?.getMutationType()
    ?.getFields();
  // if queryTypeFields is a function, invoke it to get object with queries
  const mutationsObj =
    typeof mutationTypeFields === &#x27;function&#x27;
      ? mutationTypeFields()
      : mutationTypeFields;
  for (const mutation in mutationsObj) {
    // get name of GraphQL type returned by query
    // if ofType --&gt; this is collection, else not collection
    let returnedType;
    if (mutationsObj[mutation].type.ofType) {
      returnedType = [];
      returnedType.push(mutationsObj[mutation].type.ofType.name);
    }
    if (mutationsObj[mutation].type.name) {
      returnedType = mutationsObj[mutation].type.name;
    }
    mutationMap[mutation] = returnedType;
  }
  return mutationMap;
}

/**
 *  Generates a map of queries to GraphQL object types. This mapping is used
 *  to identify and create references to cached data.
 *  @param {Object} schema - GraphQL defined schema that is used to facilitate caching by providing valid queries,
 *  mutations, and fields.
 *  @returns {Object} queryMap - Map of queries to GraphQL types.
 */
export function getQueryMap(schema: GraphQLSchema): QueryMapType {
  const queryMap: QueryMapType = {};
  // get object containing all root queries defined in the schema
  const queryTypeFields: GraphQLSchema[&#x27;_queryType&#x27;] = schema
    ?.getQueryType()
    ?.getFields();
  // if queryTypeFields is a function, invoke it to get object with queries
  const queriesObj =
    typeof queryTypeFields === &#x27;function&#x27; ? queryTypeFields() : queryTypeFields;
  for (const query in queriesObj) {
    // get name of GraphQL type returned by query
    // if ofType --&gt; this is collection, else not collection
    let returnedType;
    if (queriesObj[query].type.ofType) {
      returnedType = [];
      returnedType.push(queriesObj[query].type.ofType.name);
    }
    if (queriesObj[query].type.name) {
      returnedType = queriesObj[query].type.name;
    }
    queryMap[query] = returnedType;
  }
  return queryMap;
}

/**
 *  Generates of map of fields to GraphQL types. This mapping is used to identify
 *  and create references to cached data.
 *  @param {Object} schema - GraphQL defined schema that is used to facilitate caching by providing valid queries,
 *  mutations, and fields.
 *  @returns {Object} fieldsMap - Map of fields to GraphQL types.
 */
export function getFieldsMap(schema: GraphQLSchema): FieldsMapType {
  const fieldsMap: FieldsMapType = {};
  const typesList: GraphQLSchema[&#x27;_typeMap&#x27;] = schema?.getTypeMap();
  const builtInTypes: string[] = [
    &#x27;String&#x27;,
    &#x27;Int&#x27;,
    &#x27;Float&#x27;,
    &#x27;Boolean&#x27;,
    &#x27;ID&#x27;,
    &#x27;Query&#x27;,
    &#x27;__Type&#x27;,
    &#x27;__Field&#x27;,
    &#x27;__EnumValue&#x27;,
    &#x27;__DirectiveLocation&#x27;,
    &#x27;__Schema&#x27;,
    &#x27;__TypeKind&#x27;,
    &#x27;__InputValue&#x27;,
    &#x27;__Directive&#x27;
  ];
  // exclude built-in types
  const customTypes = Object.keys(typesList).filter(
    (type) =&gt;
      !builtInTypes.includes(type) &amp;&amp; type !== schema.getQueryType()?.name
  );
  // loop through types
  for (const type of customTypes) {
    const fieldsObj: FieldsObjectType = {};
    let fields = typesList[type]._fields;
    if (typeof fields === &#x27;function&#x27;) fields = fields();
    for (const field in fields) {
      const key: string = fields[field].name;
      const value: string = fields[field].type.ofType
        ? fields[field].type.ofType.name
        : fields[field].type.name;
      fieldsObj[key] = value;
    }
    // place assembled types on fieldsMap
    fieldsMap[type] = fieldsObj;
  }
  return fieldsMap;
}

// // TODO: Unused functions for QuellCache Class
// /**
//  * createRedisKey creates key based on field name and argument id and returns string or null if key creation is not possible
//  * @param {Object} mutationMap -
//  * @param {Object} proto -
//  * @param {Object} protoArgs -
//  * @returns {Object} redisKey if possible, e.g. &#x27;Book-1&#x27; or &#x27;Book-2&#x27;, where &#x27;Book&#x27; is name from mutationMap and &#x27;1&#x27; is id from protoArgs
//  * and isExist if we have this key in redis
//  *
//  */
// // BUG: createRedisKey is an unused function -- types should be assigned if function is used
// async function createRedisKey(mutationMap, proto, protoArgs) {
//   let isExist = false;
//   let redisKey;
//   let redisValue = null;
//   for (const mutationName in proto) {
//     const mutationArgs = protoArgs[mutationName];
//     redisKey = mutationMap[mutationName];
//     for (const key in mutationArgs) {
//       let identifier = null;
//       if (key === &#x27;id&#x27; || key === &#x27;_id&#x27;) {
//         identifier = mutationArgs[key];
//         redisKey = mutationMap[mutationName] + &#x27;-&#x27; + identifier;
//         isExist = await this.checkFromRedis(redisKey);
//         if (isExist) {
//           redisValue = await this.getFromRedis(redisKey);
//           redisValue = JSON.parse(redisValue);
//           // combine redis value and protoArgs
//           let argumentsValue;
//           for (const mutationName in protoArgs) {
//             // change later, now we assume that we have only one mutation
//             argumentsValue = protoArgs[mutationName];
//           }
//           // updateObject is not defined anywhere
//           redisValue = this.updateObject(redisValue, argumentsValue);
//         }
//       }
//     }
//   }
//   return { redisKey, isExist, redisValue };
// }

// // BUG: getIdMap is an unused function -- types should be assigned if function is used
// function getIdMap() {
//   const idMap = {};
//   for (const type in this.fieldsMap) {
//     const userDefinedIds = [];
//     const fieldsAtType = this.fieldsMap[type];
//     for (const key in fieldsAtType) {
//       if (fieldsAtType[key] === &#x27;ID&#x27;) userDefinedIds.push(key);
//     }
//     idMap[type] = userDefinedIds;
//   }
//   return idMap;
// }

// /**
//  * Toggles to false all values in a nested field not present in cache so that they will
//  * be included in the reformulated query.
//  * @param {Object} proto - The prototype or a nested field within the prototype
//  * @returns {Object} proto - updated proto with false values for fields not present in cache
//  */
// // BUG: toggleProto is an unused function -- types should be assigned if function is used
// function toggleProto(proto) {
//   if (proto === undefined) return proto;
//   for (const key in proto) {
//     if (Object.keys(proto[key]).length &gt; 0) this.toggleProto(proto[key]);
//     else proto[key] = false;
//   }
//   return proto;
// }

// /**
//  * checkFromRedis reads from Redis cache and returns a promise.
//  * @param {String} key - the key for Redis lookup
//  * @returns {Promise} A promise that represents if the key was found in the redisCache
//  */
// // BUG: checkFromRedis is an unused function -- types should be assigned if function is used
// async function checkFromRedis(key: string): Promise&lt;number&gt; {
//   try {
//     // will return 0 if key does not exists
//     const existsInRedis: number = await this.redisCache.exists(key);
//     return existsInRedis;
//   } catch (err) {
//     console.log(&#x27;err in checkFromRedis: &#x27;, err);
//     return 0;
//   }
// }

// /**
//  * execRedisRunQueue executes all previously queued transactions in Redis cache
//  * @param {String} redisRunQueue - Redis queue of transactions awaiting execution
//  */
// // BUG: execRedisRunQueue is an unused function -- types should be assigned if function is used
// async function execRedisRunQueue(
//   redisRunQueue: ReturnType&lt;typeof this.redisCache.multi&gt;
// ): Promise&lt;void&gt; {
//   try {
//     await redisRunQueue.exec();
//   } catch (err) {
//     console.log(&#x27;err in execRedisRunQueue: &#x27;, err);
//   }
// }
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:679,&quot;character&quot;:8,&quot;text&quot;:&quot;mutationTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:683,&quot;character&quot;:8,&quot;text&quot;:&quot;mutationsObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:684,&quot;character&quot;:11,&quot;text&quot;:&quot;mutationTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:685,&quot;character&quot;:8,&quot;text&quot;:&quot;mutationTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:686,&quot;character&quot;:8,&quot;text&quot;:&quot;mutationTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:687,&quot;character&quot;:25,&quot;text&quot;:&quot;mutationsObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:690,&quot;character&quot;:8,&quot;text&quot;:&quot;returnedType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:691,&quot;character&quot;:8,&quot;text&quot;:&quot;mutationsObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:691,&quot;character&quot;:31,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:691,&quot;character&quot;:36,&quot;text&quot;:&quot;ofType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:692,&quot;character&quot;:6,&quot;text&quot;:&quot;returnedType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:693,&quot;character&quot;:24,&quot;text&quot;:&quot;mutationsObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:693,&quot;character&quot;:47,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:693,&quot;character&quot;:52,&quot;text&quot;:&quot;ofType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:693,&quot;character&quot;:59,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:695,&quot;character&quot;:8,&quot;text&quot;:&quot;mutationsObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:695,&quot;character&quot;:31,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:695,&quot;character&quot;:36,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:696,&quot;character&quot;:6,&quot;text&quot;:&quot;returnedType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:696,&quot;character&quot;:21,&quot;text&quot;:&quot;mutationsObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:696,&quot;character&quot;:44,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:696,&quot;character&quot;:49,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:713,&quot;character&quot;:8,&quot;text&quot;:&quot;queryTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:717,&quot;character&quot;:8,&quot;text&quot;:&quot;queriesObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:718,&quot;character&quot;:11,&quot;text&quot;:&quot;queryTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:718,&quot;character&quot;:44,&quot;text&quot;:&quot;queryTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:718,&quot;character&quot;:64,&quot;text&quot;:&quot;queryTypeFields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:719,&quot;character&quot;:22,&quot;text&quot;:&quot;queriesObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:722,&quot;character&quot;:8,&quot;text&quot;:&quot;returnedType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:723,&quot;character&quot;:8,&quot;text&quot;:&quot;queriesObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:723,&quot;character&quot;:26,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:723,&quot;character&quot;:31,&quot;text&quot;:&quot;ofType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:724,&quot;character&quot;:6,&quot;text&quot;:&quot;returnedType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:725,&quot;character&quot;:24,&quot;text&quot;:&quot;queriesObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:725,&quot;character&quot;:42,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:725,&quot;character&quot;:47,&quot;text&quot;:&quot;ofType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:725,&quot;character&quot;:54,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:727,&quot;character&quot;:8,&quot;text&quot;:&quot;queriesObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:727,&quot;character&quot;:26,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:727,&quot;character&quot;:31,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:728,&quot;character&quot;:6,&quot;text&quot;:&quot;returnedType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:728,&quot;character&quot;:21,&quot;text&quot;:&quot;queriesObj&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:728,&quot;character&quot;:39,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:728,&quot;character&quot;:44,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:744,&quot;character&quot;:8,&quot;text&quot;:&quot;typesList&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:769,&quot;character&quot;:8,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:769,&quot;character&quot;:17,&quot;text&quot;:&quot;typesList&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:769,&quot;character&quot;:33,&quot;text&quot;:&quot;_fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:770,&quot;character&quot;:15,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:770,&quot;character&quot;:38,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:770,&quot;character&quot;:47,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:771,&quot;character&quot;:24,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:772,&quot;character&quot;:26,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:772,&quot;character&quot;:40,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:773,&quot;character&quot;:28,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:773,&quot;character&quot;:42,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:773,&quot;character&quot;:47,&quot;text&quot;:&quot;ofType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:774,&quot;character&quot;:10,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:774,&quot;character&quot;:24,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:774,&quot;character&quot;:29,&quot;text&quot;:&quot;ofType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:774,&quot;character&quot;:36,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:775,&quot;character&quot;:10,&quot;text&quot;:&quot;fields&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:775,&quot;character&quot;:24,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;quell-server/src/helpers/quellHelpers.ts&quot;,&quot;line&quot;:775,&quot;character&quot;:29,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 22 Jun 2023 16:20:41 GMT</p>
    </body>
  </html>
  